<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Visionary Infinite Canvas</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Sketch Canvas">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --ui-bg: rgba(20, 20, 20, 0.92);
            --accent: #007AFF;
            --accent-glow: rgba(0, 122, 255, 0.5);
            --text: #ffffff;
            --panel-border: rgba(255, 255, 255, 0.12);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overscroll-behavior: none;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 1000; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s ease;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        canvas { display: block; touch-action: none; background-color: #0a0a0a; }

        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        .panel {
            position: absolute; background: var(--ui-bg); backdrop-filter: blur(25px);
            border-radius: 18px; padding: 12px; pointer-events: auto;
            box-shadow: 0 12px 45px rgba(0,0,0,0.9); border: 1px solid var(--panel-border);
            display: flex; gap: 12px; align-items: center;
        }

        #toolbar {
            top: 50%; left: 20px; transform: translateY(-50%);
            flex-direction: column; padding: 25px 12px;
            margin-left: env(safe-area-inset-left);
            max-height: 80vh; overflow-y: auto;
        }

        #tools-drawer {
            position: absolute; top: 50%; left: 100px; transform: translateY(-50%);
            background: var(--ui-bg); backdrop-filter: blur(30px);
            border-radius: 24px; padding: 20px; width: 0; opacity: 0;
            overflow: hidden; transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            border: 1px solid var(--panel-border); display: flex; flex-direction: column; gap: 15px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); pointer-events: none;
        }
        #tools-drawer.open { width: 220px; opacity: 1; pointer-events: auto; left: 110px; }
        .drawer-section { display: flex; flex-direction: column; gap: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 15px; }
        .tool-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .drawer-btn { 
            width: auto; height: 45px; font-size: 11px; font-weight: 700; letter-spacing: 1px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 12px;
        }
        .drawer-btn.active { background: var(--accent); border-color: var(--accent); }

        #status-bar { 
            top: max(20px, env(safe-area-inset-top)); 
            left: 20px; font-size: 11px; color: var(--text); 
            opacity: 0.9; font-weight: 700; letter-spacing: 1.5px;
            padding: 8px 15px; border-radius: 10px;
        }

        #export-panel { 
            top: max(20px, env(safe-area-inset-top)); 
            right: 20px; display: flex; gap: 10px;
            margin-right: env(safe-area-inset-right);
        }

        button, input[type="color"], select {
            background: #1c1c1e; border: 1px solid rgba(255,255,255,0.05); color: white;
            padding: 10px; border-radius: 12px; cursor: pointer;
            font-size: 17px; width: 52px; height: 52px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        button:active { transform: scale(0.92); background: #2c2c2e; }
        .btn-gallery { background: linear-gradient(145deg, #333, #111); }
        .btn-export { background: var(--accent); font-weight: 600; width: auto; padding: 0 20px; }
        .btn-clear { background: rgba(255, 69, 58, 0.15); color: #ff453a; width: auto; padding: 0 20px; border: 1px solid rgba(255, 69, 58, 0.3); }

        select, #sizePicker { width: 70px; font-size: 14px; background: #2c2c2e; }
        .tool-active { 
            background: var(--accent) !important; 
            box-shadow: 0 0 25px var(--accent-glow);
            border-color: rgba(255,255,255,0.3);
        }

        input[type="range"] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 28px; height: 120px; margin: 12px 0;
            background: #333; border-radius: 10px;
        }

        /* Settings Styles */
        .modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: #1c1c1e;
            padding: 30px; border-radius: 28px; z-index: 100;
            width: 340px; border: 1px solid #333; pointer-events: auto;
            max-height: 80vh; overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,1);
        }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .tip-box { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 15px; margin-top: 15px; }
        .tip-box p { font-size: 12px; color: #8e8e93; margin: 5px 0; line-height: 1.4; }

        .overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.88); z-index: 99; pointer-events: auto;
        }
        
        .label-text { display: block; font-size: 10px; text-transform: uppercase; color: #8e8e93; letter-spacing: 1.2px; margin-bottom: 6px; font-weight: 700; }

        /* Gesture Hint UI */
        #gesture-zone {
            position: fixed; 
            bottom: 60px; /* Lifts it above the app switcher bar */
            left: 50%;
            transform: translateX(-50%);
            width: 90%; /* Keeps it from hitting screen edges */
            height: 80px;
            display: flex; 
            align-items: center; 
            justify-content: center;
            /* Adding a subtle glass effect helps you see the zone */
            background: rgba(255, 255, 255, 0.02); 
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 40px;
            pointer-events: auto; 
            z-index: 5;
        }
        .swipe-hint { font-size: 10px; color: #444; letter-spacing: 3px; font-weight: 800; text-transform: uppercase; pointer-events: none; opacity: 0.5; }

        #gallery-modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: #000;
            padding: 25px; border-radius: 30px; z-index: 101;
            width: 92vw; height: 85vh; border: 1px solid #222; 
            pointer-events: auto; overflow: hidden;
            display: flex; flex-direction: column;
        }

        #gallery-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 18px; overflow-y: auto; padding-top: 15px; flex-grow: 1;
        }

        .gallery-item {
            background: #111; border-radius: 15px; overflow: hidden;
            position: relative; height: 180px; border: 1px solid #222;
            transition: transform 0.2s;
        }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }

        #full-viewer {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; align-items: center; justify-content: center;
        }
        #full-viewer .close-btn { position: absolute; top: max(30px, env(safe-area-inset-top)); right: 30px; z-index: 201; font-size: 35px; color: white; cursor: pointer; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p style="color: white; margin-top: 20px; font-size: 11px; letter-spacing: 3px; font-weight: bold;">SKETCHING STUDIO</p>
</div>

<canvas id="canvas"></canvas>

<div id="gesture-zone">
    <div class="swipe-hint">‚Üê UNDO | REDO ‚Üí</div>
</div>

<div id="ui-layer">
    <div id="status-bar" class="panel">ZOOM: <span id="zoom-val">100%</span></div>
    <div id="export-panel" class="panel">
        <button class="btn-gallery" onclick="GalleryUI.open()" title="Open Gallery">üñºÔ∏è</button>
        <button class="btn-export" onclick="showExport()">EXPORT</button>
        <button onclick="AppSettings.toggle()" style="background: #2c2c2e;">‚öôÔ∏è</button>
        <button class="btn-clear" onclick="clearCanvas()">CLEAR</button>
    </div>
    
    <div id="toolbar" class="panel">
        <button id="btn-expand" onclick="ToolsDrawer.toggle()" style="background: #2c2c2e; margin-bottom: 10px;">‚óà</button>
        <span class="label-text">Color</span>
        <input type="color" id="colorPicker" value="#44ffaa">
        <span class="label-text">Tool</span>
        <select id="toolType">
            <option value="pen">Studio Pen</option>
            <option value="brush">Watercolor</option>
            <option value="pencil">Graphite</option>
            <option value="eraser">Eraser</option>
        </select>
        <span class="label-text">Size</span>
        <input type="range" id="sizePicker" min="1" max="250" value="15">
        <span class="label-text">Flow</span>
        <input type="range" id="opacityPicker" min="1" max="100" value="100">
        <button id="btn-draw" class="tool-active" onclick="setMode('draw')">‚úé</button>
        <button id="btn-pan" onclick="setMode('pan')">‚ú•</button>
    </div>

    <div id="tools-drawer">
        <div class="drawer-section">
            <span class="label-text">Precision</span>
            <div class="tool-grid">
                <button class="drawer-btn" id="tool-line" onclick="ToolsDrawer.setTool('line')">LINE</button>
                <button class="drawer-btn" id="tool-shade" onclick="ToolsDrawer.setTool('shade')">SHADE</button>
            </div>
        </div>
        <div class="drawer-section">
            <span class="label-text">Geometry</span>
            <div class="tool-grid">
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('square')">SQUARE</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('rect')">RECT</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('circle')">CIRC</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('tri')">TRI</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('star')">STAR</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('hex')">HEX</button>
                <button class="drawer-btn" onclick="ToolsDrawer.addShape('oct')">OCT</button>
            </div>
        </div>
        <div class="drawer-section">
            <span class="label-text">Shader Radius</span>
            <input type="range" id="shade-radius" min="10" max="600" value="120" style="width: 100%; height: 10px; writing-mode: horizontal-tb; -webkit-appearance: slider-horizontal;">
            <span class="label-text" style="margin-top:10px;">Shader Softness</span>
            <input type="range" id="shade-smoothness" min="0" max="100" value="80" style="width: 100%; height: 10px; writing-mode: horizontal-tb; -webkit-appearance: slider-horizontal;">
        </div>
        <button onclick="ToolsDrawer.toggle()" style="width: 100%; height: 40px; background: none; border: none; color: #666; font-size: 11px; font-weight:800;">CLOSE</button>
    </div>
</div>

<div id="settings-modal" class="modal">
    <h3 style="color:white; margin-top:0;">Visionary Settings</h3>
    <div class="setting-row">
        <span class="label-text">Enable Morphing</span>
        <input type="checkbox" id="set-morph" onchange="AppSettings.update('allowMorph', this.checked)">
    </div>
    <div class="setting-row">
        <span class="label-text">Show Grid</span>
        <input type="checkbox" id="set-grid" onchange="AppSettings.update('showGrid', this.checked)">
    </div>
    <div class="setting-row">
        <span class="label-text">Snap to Grid</span>
        <input type="checkbox" id="set-snap" onchange="AppSettings.update('snapToGrid', this.checked)">
    </div>
    <div class="tip-box">
        <span class="label-text">Studio Tips</span>
        <p><b>Swipe Bottom Area:</b> Swipe Left to Undo, Right to Redo.</p>
        <p><b>Double Tap Shape:</b> Enter Morph Mode.</p>
        <p><b>Triple Tap:</b> Commit Shape to Canvas.</p>
        <p><b>SVG:</b> Lossless vector exports.</p>
    </div>
    <div style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 20px; padding-top: 15px; text-align: center;">
        <p style="color: #666; font-size: 11px; margin: 0; letter-spacing: 1px; font-weight: 800;">VISIONARY SKETCH v0.1.9</p>
        <a href="https://github.com/vicsanity623/Sketch-Art" target="_blank" style="color: var(--accent); font-size: 12px; text-decoration: none; font-weight: 800; display: block; margin-top: 10px;">OPEN SOURCE GITHUB</a>
    </div>
    <button onclick="AppSettings.toggle()" style="width:100%; background: var(--accent); margin-top:20px; padding:15px; border-radius:12px; border:none; color:white; font-weight:bold;">DONE</button>
</div>

<div id="export-modal-overlay" class="overlay" onclick="hideExport(); if(AppSettings.panel.style.display==='block') AppSettings.toggle();"></div>

<div id="export-modal" class="modal">
    <h3 style="color:white; margin-top:0;">Export Artwork</h3>
    <label class="label-text">Format</label>
    <select id="expFormat" style="width: 100%; margin-bottom: 15px; height: 50px;">
        <option value="vector/svg">SVG (Infinite Vector)</option>
        <option value="image/png">PNG (High Res)</option>
    </select>
    <label class="label-text">Background</label>
    <select id="expBG" style="width: 100%; margin-bottom: 15px; height: 50px;">
        <option value="#0a0a0a">Black Canvas</option>
        <option value="#ffffff">True White</option>
        <option value="transparent">Transparent</option>
    </select>
    <button onclick="performExport()" style="width:100%; background: var(--accent); padding:18px; font-weight:800; border-radius:15px; border: none; color: white;">SAVE TO GALLERY</button>
</div>

<div id="gallery-modal" style="display:none;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h3 style="color:white; margin:0; font-size: 24px;">Studio Gallery</h3>
        <button onclick="hideExport()" style="width:auto; height:auto; padding:8px 20px; background:#2c2c2e; border-radius:10px; border:none; color: white;">Close</button>
    </div>
    <div id="gallery-grid"></div>
</div>

<div id="full-viewer">
    <span class="close-btn" onclick="GalleryUI.closeFull()">&times;</span>
    <div id="vector-viewer-container" style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; touch-action:none;"></div>
</div>

<script src="gallery.js"></script>
<script src="settings.js"></script>
<script src="tools.js"></script>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    const zoomDisplay = document.getElementById('zoom-val');
    
    // Command Stacks
    let strokes = [], redoStack = [], currentStroke = null, camera = { x: 0, y: 0, zoom: 1 };
    
    let mode = 'draw', isDragging = false, isPinching = false;
    let crosshairActive = false, crosshairPos = { x: 0, y: 0 }, crosshairOffset = { x: 0, y: 0 };
    let initialPinchDist = 0, initialPinchZoom = 1;

    // Gesture detection
    let gestureZone = document.getElementById('gesture-zone');
    let gestureStartX = 0, isGesturing = false;

    window.onload = () => {
        resize();
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').remove(), 500);
        
        GalleryUI.state = { scale: 1, x: 0, y: 0, lastDist: 0, lastX: 0, lastY: 0, isDragging: false, tapCount: 0, tapTimer: null };
        GalleryUI.viewFull = function(data) {
            const viewer = document.getElementById('full-viewer');
            const container = document.getElementById('vector-viewer-container');
            this.state.scale = 1; this.state.x = 0; this.state.y = 0; container.innerHTML = "";
            if (data.startsWith('data:image/svg+xml')) {
                const b64 = data.split(',')[1];
                const svgText = decodeURIComponent(escape(atob(b64)));
                container.innerHTML = svgText;
                const svgEl = container.querySelector('svg');
                svgEl.style.width = "90vw"; svgEl.style.height = "auto"; svgEl.style.maxHeight = "90vh";
                this.target = svgEl;
            } else {
                const img = document.createElement('img');
                img.src = data; img.style.maxWidth = "95%"; img.style.maxHeight = "95%";
                container.appendChild(img); this.target = img;
            }
            viewer.style.display = 'flex';
            if (!viewer.dataset.hooked) { this.initViewerEvents(viewer); viewer.dataset.hooked = "true"; }
        };
        GalleryUI.initViewerEvents = function(viewer) {
            viewer.addEventListener('touchstart', e => {
                this.state.tapCount++;
                clearTimeout(this.state.tapTimer);
                this.state.tapTimer = setTimeout(() => { this.state.tapCount = 0; }, 400);
                if (this.state.tapCount === 3) {
                    this.state.scale = 1; this.state.x = 0; this.state.y = 0;
                    this.updateView(); this.state.tapCount = 0; return;
                }
                if (e.touches.length === 2) { this.state.lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); } 
                else { this.state.isDragging = true; this.state.lastX = e.touches[0].pageX; this.state.lastY = e.touches[0].pageY; }
            });
            viewer.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    this.state.scale = Math.min(Math.max(0.5, this.state.scale * (dist / this.state.lastDist)), 100);
                    this.state.lastDist = dist;
                } else if (this.state.isDragging) {
                    this.state.x += (e.touches[0].pageX - this.state.lastX);
                    this.state.y += (e.touches[0].pageY - this.state.lastY);
                    this.state.lastX = e.touches[0].pageX; this.state.lastY = e.touches[0].pageY;
                }
                this.updateView();
            }, { passive: false });
            viewer.addEventListener('touchend', () => { this.state.isDragging = false; });
        };
        GalleryUI.updateView = function() {
            if (this.target) this.target.style.transform = `translate(${this.state.x}px, ${this.state.y}px) scale(${this.state.scale})`;
        };

        // --- Gesture Listeners for Bottom Zone ---
        gestureZone.addEventListener('touchstart', e => {
            gestureStartX = e.touches[0].clientX;
            isGesturing = true;
        });
        gestureZone.addEventListener('touchend', e => {
            if (!isGesturing) return;
            const diff = e.changedTouches[0].clientX - gestureStartX;
            if (diff < -50) undo(); // Swipe Left
            if (diff > 50) redo();  // Swipe Right
            isGesturing = false;
        });

        requestAnimationFrame(renderLoop);
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);

    function screenToWorld(sx, sy) {
        let x = (sx - camera.x) / camera.zoom;
        let y = (sy - camera.y) / camera.zoom;
        if (AppSettings.config.snapToGrid) {
            x = Math.round(x / AppSettings.config.gridSize) * AppSettings.config.gridSize;
            y = Math.round(y / AppSettings.config.gridSize) * AppSettings.config.gridSize;
        }
        return { x, y };
    }

    function undo() { 
        if (strokes.length > 0) {
            const popped = strokes.pop();
            redoStack.push(popped);
        }
    }

    function redo() {
        if (redoStack.length > 0) {
            const popped = redoStack.pop();
            strokes.push(popped);
        }
    }

    function startNewStroke(x, y) {
        const pos = screenToWorld(x, y);
        redoStack = []; // Clear redo stack on new action
        currentStroke = {
            color: document.getElementById('colorPicker').value,
            size: document.getElementById('sizePicker').value / camera.zoom,
            opacity: document.getElementById('opacityPicker').value / 100,
            type: document.getElementById('toolType').value,
            points: [{...pos, p: 0.5}]
        };
        strokes.push(currentStroke);
    }

    canvas.addEventListener('touchstart', e => {
        if (mode === 'advanced') return;
        if (mode === 'draw') {
            if (e.touches.length === 2) {
                isPinching = true; crosshairActive = true; isDragging = false; currentStroke = null;
                crosshairPos.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                crosshairPos.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            } else if (e.touches.length === 1) {
                isDragging = true;
                startNewStroke(e.touches[0].clientX, e.touches[0].clientY);
            }
        } else {
            if (e.touches.length === 2) {
                isPinching = true;
                initialPinchDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                initialPinchZoom = camera.zoom;
            } else {
                isDragging = true;
                crosshairPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (mode === 'advanced') return;
        if (mode === 'draw') {
            if (isPinching && e.touches.length === 2) {
                crosshairPos.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                crosshairPos.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            } else if (isDragging && currentStroke && e.touches.length === 1) {
                let x = e.touches[0].clientX, y = e.touches[0].clientY;
                if (crosshairActive) { x -= crosshairOffset.x; y -= crosshairOffset.y; }
                currentStroke.points.push({...screenToWorld(x, y), p: 0.5});
            }
        } else {
            if (isPinching && e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                applyZoom(initialPinchZoom * (dist / initialPinchDist) / camera.zoom, cx, cy);
            } else if (isDragging) {
                camera.x += (e.touches[0].clientX - crosshairPos.x);
                camera.y += (e.touches[0].clientY - crosshairPos.y);
                crosshairPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        if (mode === 'advanced') return;
        if (mode === 'draw') {
            if (isPinching && e.touches.length === 1) {
                isPinching = false; isDragging = true;
                crosshairOffset.x = e.touches[0].clientX - crosshairPos.x;
                crosshairOffset.y = e.touches[0].clientY - crosshairPos.y;
                startNewStroke(crosshairPos.x, crosshairPos.y);
            } else if (e.touches.length === 0) {
                isDragging = false; crosshairActive = false; currentStroke = null;
            }
        } else {
            if (e.touches.length < 2) isPinching = false;
            if (e.touches.length === 0) isDragging = false;
        }
    });

    function applyZoom(factor, cx, cy) {
        const world = screenToWorld(cx, cy);
        camera.zoom *= factor;
        camera.zoom = Math.max(0.00001, Math.min(10000, camera.zoom));
        camera.x = cx - world.x * camera.zoom;
        camera.y = cy - world.y * camera.zoom;
        zoomDisplay.innerText = Math.round(camera.zoom * 100) + '%';
    }

    function drawPaths(tCtx, cam) {
        strokes.forEach(s => {
            if (s.type === 'line' || s.type === 'shape' || s.type === 'shader') {
                if (typeof drawStaticAdvanced === 'function') drawStaticAdvanced(tCtx, s);
                return;
            }
            if (!s.points || !s.points.length) return;
            tCtx.save();
            tCtx.lineCap = 'round'; tCtx.lineJoin = 'round';
            if (s.type === 'eraser') {
                tCtx.globalCompositeOperation = 'destination-out';
                tCtx.strokeStyle = 'white'; tCtx.globalAlpha = 1;
            } else {
                tCtx.globalCompositeOperation = 'source-over';
                tCtx.strokeStyle = s.color; tCtx.fillStyle = s.color;
                tCtx.globalAlpha = s.opacity;
            }
            if (s.type === 'brush') {
                tCtx.shadowBlur = (s.size * cam.zoom) / 1.5; tCtx.shadowColor = s.color;
                tCtx.globalAlpha *= 0.4;
            } else if (s.type === 'pencil') {
                tCtx.setLineDash([0.5 / cam.zoom, 2.5 / cam.zoom]); 
                tCtx.globalAlpha *= 0.6; tCtx.lineWidth = s.size * 0.8;
            }
            if (s.points.length === 1) {
                const p = s.points[0];
                tCtx.beginPath(); tCtx.arc(p.x, p.y, s.size/2, 0, Math.PI*2); tCtx.fill();
            } else {
                tCtx.beginPath(); tCtx.moveTo(s.points[0].x, s.points[0].y);
                s.points.forEach(p => tCtx.lineTo(p.x, p.y));
                tCtx.lineWidth = (s.type === 'pencil' ? s.size * 0.8 : s.size);
                tCtx.stroke();
            }
            tCtx.restore();
        });
    }

    function renderLoop() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);
        if (AppSettings.config.showGrid) {
            ctx.beginPath(); ctx.strokeStyle = "rgba(255,255,255,0.05)"; ctx.lineWidth = 1 / camera.zoom;
            const size = AppSettings.config.gridSize;
            const startX = Math.floor((-camera.x/camera.zoom)/size)*size;
            const startY = Math.floor((-camera.y/camera.zoom)/size)*size;
            const endX = startX + canvas.width/camera.zoom + size;
            const endY = startY + canvas.height/camera.zoom + size;
            for(let x = startX; x < endX; x += size) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
            for(let y = startY; y < endY; y += size) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
            ctx.stroke();
        }
        drawPaths(ctx, camera);
        if(typeof drawAdvanced === 'function') drawAdvanced(ctx);
        ctx.restore();
        if (crosshairActive) {
            ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.strokeStyle = "#00ff66"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(crosshairPos.x - 40, crosshairPos.y); ctx.lineTo(crosshairPos.x + 40, crosshairPos.y);
            ctx.moveTo(crosshairPos.x, crosshairPos.y - 40); ctx.lineTo(crosshairPos.x, crosshairPos.y + 40); ctx.stroke();
            ctx.beginPath(); ctx.arc(crosshairPos.x, crosshairPos.y, 15, 0, Math.PI * 2); ctx.stroke();
        }
        requestAnimationFrame(renderLoop);
    }

    function setMode(m) {
        mode = m; isDragging = false; crosshairActive = false; currentStroke = null;
        document.getElementById('btn-draw').className = m==='draw'?'tool-active':'';
        document.getElementById('btn-pan').className = m==='pan'?'tool-active':'';
        if (m !== 'advanced') document.getElementById('tools-drawer').classList.remove('open');
    }

    function clearCanvas() { if(confirm("Wipe the canvas?")) { strokes = []; redoStack = []; camera = {x:0,y:0,zoom:1}; } }
    function showExport() { document.getElementById('export-modal').style.display = 'block'; document.getElementById('export-modal-overlay').style.display = 'block'; }
    function hideExport() { document.getElementById('export-modal').style.display = 'none'; document.getElementById('gallery-modal').style.display = 'none'; document.getElementById('settings-modal').style.display = 'none'; document.getElementById('export-modal-overlay').style.display = 'none'; }

    async function performExport() {
        if (!strokes.length) return;
        const format = document.getElementById('expFormat').value;
        const bgChoice = document.getElementById('expBG').value;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        strokes.forEach(s => {
            if (s.points) s.points.forEach(p => {
                const r = s.type === 'shader' ? s.radius : (s.size || 0);
                minX = Math.min(minX, p.x - r); minY = Math.min(minY, p.y - r);
                maxX = Math.max(maxX, p.x + r); maxY = Math.max(maxY, p.y + r);
            });
            if (s.type === 'line') { minX = Math.min(minX, s.a.x, s.b.x); minY = Math.min(minY, s.a.y, s.b.y); maxX = Math.max(maxX, s.a.x, s.b.x); maxY = Math.max(maxY, s.a.y, s.b.y); }
            if (s.type === 'shape' && s.points) { s.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); }
        });
        const pad = Math.max(maxX - minX, maxY - minY) * 0.05;
        minX -= pad; minY -= pad; maxX += pad; maxY += pad;
        const worldW = maxX - minX, worldH = maxY - minY;
        let finalData;
        if (format === 'vector/svg') {
            let svgDefs = `<defs><filter id="brushBlur"><feGaussianBlur stdDeviation="3" /></filter>`;
            let svgBody = "";
            strokes.forEach((s, idx) => {
                if (s.type === 'eraser') return;
                const style = `opacity="${s.opacity || 1}"`;
                if (s.type === 'shader') {
                    const id = `sh-${idx}`, core = Math.max(0.01, 1 - (s.smoothness / 100));
                    svgDefs += `<radialGradient id="${id}"><stop offset="0%" stop-color="${s.color}" stop-opacity="1"/><stop offset="${core*100}%" stop-color="${s.color}" stop-opacity="0.3"/><stop offset="100%" stop-color="${s.color}" stop-opacity="0"/></radialGradient>`;
                    s.points.forEach(p => { svgBody += `<circle cx="${p.x}" cy="${p.y}" r="${s.radius}" fill="url(#${id})" ${style} />`; });
                } else if (s.type === 'shape' && s.points) {
                    const shStyle = `fill="none" stroke="${s.color}" stroke-width="${s.thickness}" stroke-linecap="round" stroke-linejoin="round" ${style}`;
                    let pts = s.points.map(p => `${p.x},${p.y}`).join(' ');
                    svgBody += `<polygon points="${pts}" ${shStyle} />`;
                } else if (s.type === 'line') {
                    svgBody += `<line x1="${s.a.x}" y1="${s.a.y}" x2="${s.b.x}" y2="${s.b.y}" stroke="${s.color}" stroke-width="${s.thickness}" stroke-linecap="round" ${style}/>`;
                } else if (s.points && s.points.length > 1) {
                    let d = `M ${s.points[0].x} ${s.points[0].y} `;
                    s.points.forEach((p, i) => { if(i>0) d += `L ${p.x} ${p.y} `; });
                    let st = `fill="none" stroke="${s.color}" stroke-width="${s.size}" stroke-linecap="round" stroke-linejoin="round" ${style}`;
                    if (s.type === 'pencil') st += ` stroke-dasharray="1,3"`;
                    if (s.type === 'brush') st += ` filter="url(#brushBlur)"`;
                    svgBody += `<path d="${d}" ${st} />`;
                }
            });
            svgDefs += `</defs>`;
            let svgFull = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${worldW} ${worldH}" width="${worldW}" height="${worldH}">`;
            if (bgChoice !== 'transparent') svgFull += `<rect x="${minX}" y="${minY}" width="${worldW}" height="${worldH}" fill="${bgChoice}"/>`;
            svgFull += svgDefs + svgBody + `</svg>`;
            finalData = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgFull)));
        } else {
            const width = parseInt(document.getElementById('expWidth').value);
            const scale = width / worldW;
            const height = worldH * scale;
            const out = document.createElement('canvas'); out.width = width; out.height = height;
            const octx = out.getContext('2d', {alpha: true});
            if (bgChoice !== 'transparent') { octx.fillStyle = bgChoice; octx.fillRect(0,0,width,height); }
            octx.save(); octx.scale(scale, scale); octx.translate(-minX, -minY);
            drawPaths(octx, { zoom: scale }); octx.restore();
            finalData = out.toDataURL(format);
        }
        try { await GalleryDB.save(finalData, format); } catch(e) { console.error(e); }
        hideExport();
    }
</script>
</body>
</html>